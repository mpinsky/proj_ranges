abline(v=0)
plot(fst, fis)
summary(lm(fis ~ fst))
runif(30, 0, 100)
reefs = runif(30, 0, 100)
l = rnorm(10000, sd=10)
summary(l)
l = rnorm(10000, mean=50, sd=10)
summary(l)
sd(l)
keep = rep(FALSE, length(l)); for(i in 1:length(reefs)) keep = keep | (abs(l-reefs[i]) < 1)
sum(keep)
hist(l)
hist(l[keep])
hist(l, breaks=100)
hist(l[keep], breaks=100)
abline(v=reefs)
abline(v=reefs, col='red')
sd(l[keep])
reefs2 = runif(10,0,100)
keep2 = rep(FALSE, length(l)); for(i in 1:length(reefs2)) keep2 = keep2 | (abs(l-reefs2[i]) < 1)
hist(l[keep2])
abline(v=reefs2, col='red')
hist(l[keep2], breaks=100)
abline(v=reefs2, col='red')
sd(l[keep2])
sds = rep(NA, 100)
l = rnorm(10000, mean=50, sd=10)
for(i in 1:length(sds)){	reefs = runif(10, 0, 100)	keep = rep(FALSE, length(l)); for(j in 1:length(reefs)) keep = keep | (abs(l-reefs[j]) < 1)	sds[i] = sd(l[keep])}
summary(sds)
hist(sds)
sds = rep(NA, 100)reefs = runif(10, 0, 100)
for(i in 1:length(sds)){	l = rnorm(1000, mean=50, sd=10)	keep = rep(FALSE, length(l)); for(j in 1:length(reefs)) keep = keep | (abs(l-reefs[j]) < 1)	sds[i] = sd(l[keep])}summary(sds)
hist(sds)
sds = rep(NA, 1000)reefs = runif(10, 0, 100)for(i in 1:length(sds)){	l = rnorm(1000, mean=50, sd=10)	keep = rep(FALSE, length(l)); for(j in 1:length(reefs)) keep = keep | (abs(l-reefs[j]) < 1)	sds[i] = sd(l[keep])}summary(sds)hist(sds)
for(i in 1:length(sds)){	l = rnorm(1000, mean=50, sd=10)	keep = rep(FALSE, length(l)); for(j in 1:length(reefs)) keep = keep | (abs(l-reefs[j]) < 1)	sds[i] = sd(l[keep])}summary(sds)hist(sds)
7000/5/2
sqrt(700)
sqrt(600)
sqrt(850)
1126/120
sqrt(c(6000, 7000, 8500)/2/9)
sqrt(c(6000, 7000, 8500)/2/5)
library(RColorBrewer)mq = c(1,1) # manmade capital quantitymp = c(1, 0.8) # pricehq = c(1,1) # human capital quantityhp = c(1, 0.4)nq = c(1,0.6) # natural capital quantitynp = c(1, 1.25)quartz(width=7,height=4)par(mfrow=c(1,2))
cols = brewer.pal(6, 'Paired')
t = c(0,1)
par(mfrow=c(1,2))
plot(t, mq, col=cols[1], type='o')
par(mfrow=c(1,2))plot(t, mq, col=cols[1], type='o', ylim=ylims)
ylims = c(0,1.1)
par(mfrow=c(1,2))plot(t, mq, col=cols[1], type='o', ylim=ylims)
par(mfrow=c(1,2))plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16)
lines(t,hq, col=cols[2], type='o', pch=16)
mq
hq
mq = c(1.05,1.05) # manmade capital quantitymp = c(1, 0.8) # pricehq = c(1,1) # human capital quantityhp = c(1, 0.4)nq = c(0.95,0.6) # natural capital quantitynp = c(1, 1.25)t = c(0,1)
par(mfrow=c(1,2))plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16)lines(t,hq, col=cols[2], type='o', pch=16)
lines(t,nq, col=cols[3], type='o', pch=16)
par(mfrow=c(1,2), las=2)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16)lines(t,hq, col=cols[2], type='o', pch=16)lines(t,nq, col=cols[3], type='o', pch=16)
par(mfrow=c(1,2), las=2)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16)lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)
plot(t, mp, col=cols[2], type='o', ylim=ylims, pch=16)lines(t,hp, col=cols[4], type='o', pch=16)lines(t,np, col=cols[6], type='o', pch=16)
ylims = c(0,1.3)
par(mfrow=c(1,2), las=2)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16)lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[2], type='o', ylim=ylims, pch=16)lines(t,hp, col=cols[4], type='o', pch=16)lines(t,np, col=cols[6], type='o', pch=16)
par(mfrow=c(1,3), las=2)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Quantity')lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Price')lines(t,hp, col=cols[3], type='o', pch=16)lines(t,np, col=cols[5], type='o', pch=16)plot(t, mp*mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Value')lines(t,hp*hq, col=cols[3], type='o', pch=16)lines(t,np*nq, col=cols[5], type='o', pch=16)
quartz(width=9,height=4)par(mfrow=c(1,3), las=2)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Quantity')lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Price')lines(t,hp, col=cols[3], type='o', pch=16)lines(t,np, col=cols[5], type='o', pch=16)plot(t, mp*mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Value')lines(t,hp*hq, col=cols[3], type='o', pch=16)lines(t,np*nq, col=cols[5], type='o', pch=16)
quartz(width=6,height=3)par(mfrow=c(1,3), las=2)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Quantity')lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Price')lines(t,hp, col=cols[3], type='o', pch=16)lines(t,np, col=cols[5], type='o', pch=16)plot(t, mp*mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Value')lines(t,hp*hq, col=cols[3], type='o', pch=16)lines(t,np*nq, col=cols[5], type='o', pch=16)
?par
par(mfrow=c(1,3), las=1, mai=c(0.5)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Quantity')lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Price')lines(t,hp, col=cols[3], type='o', pch=16)lines(t,np, col=cols[5], type='o', pch=16)plot(t, mp*mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Value')lines(t,hp*hq, col=cols[3], type='o', pch=16)lines(t,np*nq, col=cols[5], type='o', pch=16)
quartz(width=6,height=3)par(mfrow=c(1,3), las=1, mai=c(0.5)plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Quantity')lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Price')lines(t,hp, col=cols[3], type='o', pch=16)lines(t,np, col=cols[5], type='o', pch=16)plot(t, mp*mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Value')lines(t,hp*hq, col=cols[3], type='o', pch=16)lines(t,np*nq, col=cols[5], type='o', pch=16)
quartz(width=6,height=3)par(mfrow=c(1,3), las=1, mai=c(0.5, 0.5, 0.2, 0.1))plot(t, mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Quantity')lines(t,hq, col=cols[3], type='o', pch=16)lines(t,nq, col=cols[5], type='o', pch=16)plot(t, mp, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Price')lines(t,hp, col=cols[3], type='o', pch=16)lines(t,np, col=cols[5], type='o', pch=16)plot(t, mp*mq, col=cols[1], type='o', ylim=ylims, pch=16, ylab='Value')lines(t,hp*hq, col=cols[3], type='o', pch=16)lines(t,np*nq, col=cols[5], type='o', pch=16)
x=rpois(1000, 10)
hist(x)
hist(x, breaks=c(0,30,by=1))
hist(x, breaks=seq(0,30,by=1))
hist(x, breaks=seq(-0.5,30,by=1))
hist(rpois(10000,10), breaks=seq(-0.5,30,by=1), col='grey')
hist(rpois(10000,5), breaks=seq(-0.5,30,by=1), col='grey')
hist(rpois(10000,3), breaks=seq(-0.5,30,by=1), col='grey')
hist(rpois(10000,4), breaks=seq(-0.5,30,by=1), col='grey')
hist(rpois(10000,5), breaks=seq(-0.5,30,by=1), col='grey')
x = rpois(100, 0.25)/100
hist(x, col='grey')
?rpois
x= rgeom(100,0.25)/100
hist(x, col='grey')
x[1:10]
x = rbinom(1000, 100, 0.25)
x[1:10]
x = rbinom(1000, 100, 0.25)/100
x[1:10]
hist(x, col='grey')
abline(v=0.33)
sum(x>=0.33)/length(x)
x = rbinom(1000, 50, 0.25)/100
hist(x, col='grey')
abline(v=0.33)
x = rbinom(10000, 50, 0.25)/50
hist(x, col='grey')
abline(v=0.33)
sum(x>=0.33)/length(x)
x = rbinom(1000000, 100, 0.25)/100
hist(x, col='grey')
sum(x>=0.33)/length(x)
x = rbinom(1000000, 50, 0.25)/50
sum(x>=0.33)/length(x)
Correlations among variables?
la = 1:100
fa = 4.7559*la^2.6399
plot(la, fa)
biomassave = dara.frame(region = rep(myregions, c(80,80)), year = rep(2020:2099, 2)) # total abundance (2020-2099) for
runtype <- 'testseason'############################## Choose species to project ##############################load(paste('output/modeldiag_', runtype, '.Rdata', sep='')) # model diagnosticsprojspp <- modeldiag$sppocean[modeldiag$auc.tt >= 0.75 & !is.na(modeldiag$auc.tt)] # from Elith et al., but there may be better criteria to uselength(projspp) # number of species to project to# find the files with these species for our chosen model fitfiles <- list.files(modfolder)files <- files[grepl(paste('_', runtype, '_', sep=''), files) & grepl(paste(gsub('/|\\(|\\)', '', projspp), collapse='|'), gsub('/|\\(|\\)', '', files))] # have to strip out parentheses and slashes from file and taxon names so that grep doesn't interpret themlength(files) # should match length of projspp
options(warn=1) # print warnings as they occur
load('~/Documents/Rutgers/NorthAmerican_survey_data/NEFSC/2015-01-30/Survdat.RData')
ls()
head(survdat)
t = 1:100
x = sin(t/10)
plot(t,x)
x = sin(t/30) + rnorm
x = sin(t/30) + rnorm(length(t))
plot(t,x, type='l')
x = sin(t/30) + rnorm(length(t), sd=0.3)
plot(t,x, type='l')
x = sin(t/5) + rnorm(length(t))
plot(t,x, type='l')
x = sin(t/5) + rnorm(length(t), sd=0.3)
plot(t,x, type='l')
x = sin(t/6) + rnorm(length(t), sd=0.3)
plot(t,x, type='l')
x = sin(t/6) +0.5*cos(t/10)+ rnorm(length(t), sd=0.3)
plot(t,x, type='l')
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n')
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=2)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3)
x = sin(t/6) +0.6*cos(t/10)+ rnorm(length(t), sd=0.3)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3)
x = sin(t/6) +0.6*cos(t/15)+ rnorm(length(t), sd=0.3)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3)
y = x + 0.02*t
plot(t,y, type='l', bty='n', xaxt='n', yaxt='n', lwd=3)
y = x + 0.2*t
plot(t,y, type='l', bty='n', xaxt='n', yaxt='n', lwd=3)
range(x)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,5))
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,6))
y = x + t/20
lines(t,y)
y = x + t/15
lines(t,y)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,8))
lines(t,y)
y = x + t/12
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,8))
lines(t,y)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,10))
lines(t,y)
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,10))
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,10), col='white')
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,10), col='white', bg='black')
plot(t,x, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,10), col='white', xlab='', ylab='')
plot(t,y, type='l', bty='n', xaxt='n', yaxt='n', lwd=3, ylim=c(-2,10), col='white', xlab='', ylab='')
sigma <- 18 # kmTsp = 365 # duration of spawning seasonTL = 3 # time scale for settlement events (eddy duration)C = 225 # coastline lengthr = 25 # settlement event scale (eddy size)P = Tsp/TL*C/r
P
P = Tsp/TL*C/r*fsv
P
fsv = 0.01P = Tsp/TL*C/r*fsv
P
?sample
i=1
n = 100sigma_est = numeric(n)
sigma <- 18 # kmnlarv = 400 # number of larvae sampled each yearTsp = 365 # duration of spawning seasonTL = 3 # time scale for settlement events (eddy duration)C = 225 # coastline lengthr = 25 # settlement event scale (eddy size)fsv = 0.01 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per season
yks = rep(0, P) # source	xks = rnorm(P, mean = 0, sd = sigma) # destination
xks
packets = sample(1:P, size=nlarv)
packets = sample(1:P, size=nlarv, replace=TRUE)
packets
j=1
sum(packets==j)
xks_larv[packets == j]
xks_larv = numeric(nlarv) # destinations of individual larvae
xks_larv[packets == j]
xks_larv = rep(NA, nlarv) # destinations of individual larvae
xks_larv[packets == j]
xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)
xks_larv[packets == j]
for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}
xks_larv
hist(xks_larv)
sd(xks_larv)
n = 100sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}
hist(sigma_est)
n = 1000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est)
n = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est)
hist(sigma_est, breaks=20, col='grey')
abline(v=c(27,35), col='red')
sigma <- 18 # kmnlarv = 400 # number of larvae sampled each yearTsp = 365 # duration of spawning seasonTL = 3 # time scale for settlement events (eddy duration)C = 225 # coastline lengthr = 25 # settlement event scale (eddy size)fsv = 0.005 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonn = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est, breaks=20, col='grey')abline(v=c(27,35), col='red')
P
sum(sigma_est>27)/length(sigma_est)sum(sigma_est>35)/length(sigma_est)
sigma <- 18 # kmnlarv = 400 # number of larvae sampled each yearTsp = 365 # duration of spawning seasonTL = 3 # time scale for settlement events (eddy duration)C = 225 # coastline length, kmr = 10 # settlement event scale (eddy size), kmfsv = 0.005 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonP
fsv = 0.001 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonP
n = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est, breaks=20, col='grey')abline(v=c(27,35), col='red')sum(sigma_est>27)/length(sigma_est) # sum(sigma_est>35)/length(sigma_est)
sigma <- 18 # kmnlarv = 100 # number of larvae sampled each yearTsp = 365 # duration of spawning seasonTL = 3 # time scale for settlement events (eddy duration)C = 225 # coastline length, kmr = 10 # settlement event scale (eddy size), kmfsv = 0.001 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonPn = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est, breaks=20, col='grey')abline(v=c(27,35), col='red')sum(sigma_est>27)/length(sigma_est) # sum(sigma_est>35)/length(sigma_est)
quantile(sigma_est, c(0.025, 0.975)
)
P
sigma <- 18 # kmnlarv = 100 # number of larvae matched to parents each yearTsp = 365 # duration of spawning seasonTL = 20 # time scale for settlement events (eddy duration) (Ji: few days to 10s days)C = 225 # coastline length, kmr = 10 # settlement event scale (eddy size), km (Ji: 10s of kmfsv = 0.01 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonP
n = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est, breaks=20, col='grey')abline(v=c(27,35), col='red')sum(sigma_est>27)/length(sigma_est) # sum(sigma_est>35)/length(sigma_est)quantile(sigma_est, c(0.025, 0.975))
sigma <- 18 # kmnlarv = 100 # number of larvae matched to parents each yearTsp = 365 # duration of spawning seasonTL = 20 # time scale for settlement events (eddy duration) (Ji: few days to 10s days)C = 225 # coastline length, kmr = 10 # settlement event scale (eddy size), km (Ji: 10s of kmfsv = 0.1 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonPn = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est, breaks=20, col='grey')abline(v=c(27,35), col='red')sum(sigma_est>27)/length(sigma_est) # sum(sigma_est>35)/length(sigma_est)quantile(s
igma_est, c(0.025, 0.975))
sigma <- 18 # kmnlarv = 100 # number of larvae matched to parents each yearTsp = 365 # duration of spawning seasonTL = 20 # time scale for settlement events (eddy duration) (Ji: few days to 10s days)C = 225 # coastline length, kmr = 20 # settlement event scale (eddy size), km (Ji: 10s of kmfsv = 0.1 # fraction of eddies with larvaeP = round(Tsp/TL*C/r*fsv) # number of eddies per seasonPn = 10000sigma_est = numeric(n)for(i in 1:n){	yks = rep(0, P) # sources are at 0 for simplicity	xks = rnorm(P, mean = 0, sd = sigma) # destination of packet centers	packets = sample(1:P, size=nlarv, replace=TRUE) # which packet each larva is in	xks_larv = rep(NA, nlarv) # destinations of individual larvae	for(j in 1:P){ # for each packet		xks_larv[packets == j] = runif(sum(packets==j), min=xks[j]-r/2, max=xks[j]+r/2)	}	sigma_est[i] = sd(xks_larv)}hist(sigma_est, breaks=20, col='grey')abline(v=c(27,35), col='red')sum(sigma_est>27)/length(sigma_est) # sum(sigma_est>35)/length(sigma_est)quantile(s
igma_est, c(0.025, 0.975))
n = 5allocs = matrix(NA, nrow=12, ncol=5)for(i in 1:12){	locs = sort(floor(runif(n, 0,25)))	while(any(diff(locs) == 0)){		locs = sort(floor(runif(n, 0,25)))	}	allocs[i,] = locs}allocs
load('~/Documents/Rutgers/NorthAmerican_survey_data/NEFSC/2015-08-05/Survdat.RData')
ls
ls()
head(survdat)
setwd('~/Documents/Rutgers/Range projections/proj_ranges')load("data/trawl_allregionsforprojections_wSST_2015-06-02.RData") # loads dat
dat = dat[!is.na(dat$lat) & !is.na(dat$lon),]
dat$lon[dat$lon < 0] = dat$lon[dat$lon < 0] + 360 # fix lons to only positive to match CMIP5 data
temp = dat[complete.cases(dat[,c('lat', 'lon', 'depth')]),c('region', 'stratum', 'lat', 'lon', 'depth', 'year', 'yearsurv', 'month', 'bottemp', 'surftemp')]		temp = droplevels(temp)		rm(dat)	# Add grid indicator for the climatology	gridsize=0.25 # size of grid of the climate data, in degrees	temp$latgrid = floor(temp$lat/gridsize)*gridsize + gridsize/2 # round to nearest grid center	temp$longrid = floor(temp$lon/gridsize)*gridsize + gridsize/2#
	# Trim to no later than December 16, 2005 (to match historical period in CMIP5)	temp = temp[temp$year<2006,]#
	# Label by decade within each region (using start date within region as start of the decades)	regs = sort(unique(temp$region))	temp$decade = NA	for(i in 1:length(regs)){		inds = temp$region == regs[i]		yrs = sort(unique(temp$year[inds]))		decs = seq(min(yrs), max(yrs), by=10) + 5 # center of each decade		temp$decade[inds] = floor((temp$yearsurv[inds] - min(decs)+5)/10)*10+min(decs)	}	# Label by season	temp$season = NA	inds = temp$month <= 3	temp$season[inds] = 1	inds = temp$month > 3 & temp$month<=6	temp$season[inds] = 2	inds = temp$month > 6 & temp$month<=9	temp$season[inds] = 3	inds = temp$month > 9	temp$season[inds] = 4
head(dat)
head(temp)
load("data/trawl_allregionsforprojections_wSST_2015-06-02.RData") # loads dat# remove NA lat/lon	dat = dat[!is.na(dat$lat) & !is.na(dat$lon),]
head(dat)
rm(dat)
climdec = aggregate(list(bottemp.clim = temp$bottemp, surftemp.clim = temp$surftemp, depth=temp$depth), by=list(lat = temp$latgrid, lon = temp$longrid, decade = temp$decade, region=temp$region, season=temp$season), FUN=mean, na.rm=TRUE)		dim(climdec) # 20,228		names(climdec)
clim = aggregate(list(bottemp.clim = climdec$bottemp.clim, surftemp.clim = climdec$surftemp.clim, depth=climdec$depth), by=list(lat = climdec$lat, lon = climdec$lon,  region=climdec$region, season=climdec$season), FUN=mean) # don't remove NAs because it would mean dropping a decade		dim(clim) # 9988		names(clim)
require(lattice)		cols = colorRampPalette(colors = c('blue', 'white', 'red'))		pdf(width=30, height=12, file=paste('figures/climBT_grid.pdf', sep=''))		levelplot(bottemp.clim ~ lon*lat|region*season, scales = list(x='free', y='free'), data=clim, at = seq(0,1, length.out=40), col.regions=cols, panel=function(...,z, subscripts, at){				panel.fill(col='light grey')				panel.levelplot(..., z=z, subscripts=subscripts, at=seq(min(z[subscripts], na.rm=TRUE), max(z[subscripts], na.rm=TRUE), length.out=20))})		dev.off()
pdf(width=30, height=12, file=paste('figures/climSST_grid.pdf', sep=''))		levelplot(surftemp.clim ~ lon*lat|region*season, scales = list(x='free', y='free'), data=clim, at = seq(0,1, length.out=40), col.regions=cols, panel=function(...,z, subscripts, at){				panel.fill(col='light grey')				panel.levelplot(..., z=z, subscripts=subscripts, at=seq(min(z[subscripts], na.rm=TRUE), max(z[subscripts], na.rm=TRUE), length.out=20))})		dev.off()
table(clim$region, clim$season)
keep = c('AFSC_Aleutians 2', 'AFSC_Aleutians 3', 'AFSC_EBS 2', 'AFSC_EBS 3', 'AFSC_GOA 3', 'AFSC_WCTri 3', 'DFO_NewfoundlandFall 4', 'DFO_NewfoundlandSpring 2', 'DFO_ScotianShelf 1', 'DFO_ScotianShelf 3', 'DFO_ScotianShelf 4', 'DFO_SoGulf 3', 'NEFSC_NEUSFall 4', 'NEFSC_NEUSSpring 1', 'NEFSC_NEUSSpring 2', 'NWFSC_WCAnn 3', 'SEFSC_GOMex 2', 'SEFSC_GOMex 3')
clim = clim[paste(clim$region, clim$season) %in% keep,] # trim down to these region/season combinations	dim(clim) # 8046climold = clim # save a copy
sskeepgrids = clim[clim$region == 'DFO_ScotianShelf' & !duplicated(clim[,c('region', 'lat', 'lon', 'season')]), c('region', 'lat', 'lon', 'season')] # list of Scotian Shelf gridcells and the season in which they appear	sskeepgrids2 = reshape(sskeepgrids, direction='wide', timevar='season', v.names='season', idvar = c('region', 'lat', 'lon')) # reshape to wide to easily see which grids cells appear in which seasons	sskeepgrids3 = sskeepgrids2[rowSums(!is.na(sskeepgrids2[,c('season.1', 'season.3', 'season.4')]))>1,] # only keep those grids present in at least 2 seasons (e.g., not only winter)	clim = clim[clim$region != 'DFO_ScotianShelf' | (paste(clim$lat, clim$lon) %in% paste(sskeepgrids3$lat, sskeepgrids3$lon)),] # trim out the Scotian Shelf grids that didn't make the cut
nrow(climold)-nrow(clim) # dropped 165 rows	nrow(sskeepgrids2)-nrow(sskeepgrids3) # also dropped 165 rows from Scotian Shelf: perfect (to make sure I didn't drop anything extra)
# useful functions from http://www.r-bloggers.com/great-circle-distance-calculations-in-r/	deg2rad <- function(deg) return(deg*pi/180)	# Haversine formula (hf)	gcd.hf <- function(long1, lat1, long2, lat2) {		long1 = deg2rad(long1); long2 = deg2rad(long2); lat1 = deg2rad(lat1); lat2=deg2rad(lat2)		R <- 6371 # Earth mean radius [km]		delta.long <- (long2 - long1)		delta.lat <- (lat2 - lat1)		a <- sin(delta.lat/2)^2 + cos(lat1) * cos(lat2) * sin(delta.long/2)^2		c <- 2 * asin(pmin(1,sqrt(a)))		return(d = R * c) # Distance in km	}
regs = sort(unique(clim$region))	for(i in 1:length(regs)){		grids = clim[!duplicated(clim[,c('lat', 'lon')]) & clim$region == regs[i], c('lat', 'lon', 'depth')] # will arbitrarily pull the first depth value for each grid cell		seasons = sort(unique(clim$season[clim$region == regs[i]]))		for(j in seasons){ # for each season			thesegrids = clim[!duplicated(clim[,c('lat', 'lon', 'season')]) & clim$region == regs[i] & clim$season == j, c('lat', 'lon')]			newrows = grids[!(paste(grids$lat, grids$lon) %in% paste(thesegrids$lat, thesegrids$lon)),]			if(nrow(newrows)>0){				newrows$region = regs[i]				newrows$season = j				newrows$bottemp.clim = NA				newrows$surftemp.clim = NA				clim = rbind(clim, newrows)			}		}	}	dim(clim) # 8633
inds = which(is.na(clim$bottemp.clim)) # points to fill for BT	clim$bottemp.clim.int = clim$bottemp.clim # interpolated BT	for(i in 1:length(inds)){		lt = clim$lat[inds[i]]		ln = clim$lon[inds[i]]		nn = clim$lat %in% c(lt, lt-gridsize, lt+gridsize, lt-gridsize*2, lt+gridsize*2, lt-gridsize*3, lt+gridsize*3) & clim$lon %in% c(ln, ln-gridsize, ln+gridsize, ln-gridsize*2, ln+gridsize*2, ln-gridsize*3, ln+gridsize*3) & clim$region == unique(clim$region[inds[i]]) & clim$season == unique(clim$season[inds[i]]) # nearest neighbors from same region and season (including the focal grid cell)		dist = pmax(1, gcd.hf(ln, lt, clim$lon[nn], clim$lat[nn])) # distances in km, but set 1km as a floor (so no zeros)		clim$bottemp.clim.int[inds[i]] = weighted.mean(x=clim$bottemp.clim[nn], w=1/dist, na.rm=TRUE) # weight values from 3 grid cells in every direction by 1/distance	}
sum(is.na(clim$bottemp.clim.int)) # = 251: some missing values		unique(clim$region[is.na(clim$bottemp.clim.int)]) # EBS, NEUSSpring, GOMex		table(clim$region, is.na(clim$bottemp.clim.int))
inds = which(is.na(clim$surftemp.clim)) # points to fill for SST
clim$surftemp.clim.int = clim$surftemp.clim # interpolated ST
for(i in 1:length(inds)){		lt = clim$lat[inds[i]]		ln = clim$lon[inds[i]]		nn = clim$lat %in% c(lt, lt-gridsize, lt+gridsize, lt-gridsize*2, lt+gridsize*2, lt-gridsize*3, lt+gridsize*3) & clim$lon %in% c(ln, ln-gridsize, ln+gridsize, ln-gridsize*2, ln+gridsize*2, ln-gridsize*3, ln+gridsize*3) & clim$region == unique(clim$region[inds[i]])  & clim$season == unique(clim$season[inds[i]]) # nearest neighbors (including the focal grid cell)		dist = pmax(1,gcd.hf(ln, lt, clim$lon[nn], clim$lat[nn])) # distances in km (>=1)		clim$surftemp.clim.int[inds[i]] = weighted.mean(x=clim$surftemp.clim[nn], w=1/dist, na.rm=TRUE)	}
sum(is.na(clim$surftemp.clim.int)) # = 2373: many missing SST values
unique(clim$region[is.na(clim$surftemp.clim.int)]) # Newfoundland Fall and Spring and West Coast Annual still missing, plus DFO_SoGulf. That's what we'd expect based on missing SST data. Also EBS, GOA, NEUSSpring, GOMex.
table(clim$region, is.na(clim$surftemp.clim.int))
inds = which(is.na(clim$depth)) # points to fill for depth (0)		sum(inds)
require(lattice)	cols = colorRampPalette(colors = c('blue', 'white', 'red'))	pdf(width=30, height=12, file=paste('figures/climBT_grid_interp.pdf', sep=''))	levelplot(bottemp.clim.int ~ lon*lat|region*season, scales = list(x='free', y='free'), data=clim, at = seq(0,1, length.out=40), col.regions = cols, panel=function(...,z, subscripts, at){			panel.fill(col='light grey')			panel.levelplot(..., z=z, subscripts=subscripts, at=seq(min(z[subscripts], na.rm=TRUE), max(z[subscripts], na.rm=TRUE), length.out=20))})	dev.off()
pdf(width=30, height=12, file=paste('figures/climSST_grid_interp.pdf', sep=''))	levelplot(surftemp.clim.int ~ lon*lat|region*season, scales = list(x='free', y='free'), data=clim, at = seq(0,1, length.out=40), col.regions = cols, panel=function(...,z, subscripts, at){			panel.fill(col='light grey')			panel.levelplot(..., z=z, subscripts=subscripts, at=seq(min(z[subscripts], na.rm=TRUE), max(z[subscripts], na.rm=TRUE), length.out=20))})	dev.off()
pdf(width=10, height=6, file=paste('figures/climDepth_grid_interp.pdf', sep=''))	levelplot(depth ~ lon*lat|region, scales = list(x='free', y='free'), data=clim, at = seq(0,1, length.out=40), col.regions = terrain.colors, panel=function(...,z, subscripts, at){			panel.fill(col='light grey')			panel.levelplot(..., z=z, subscripts=subscripts, at=quantile(z[subscripts], probs = seq(0,1, length.out=40), na.rm=TRUE))})	dev.off()
climgridsize=1 # size of grid of the climate data, in degrees	clim$latgrid = floor(clim$lat/climgridsize)*climgridsize + climgridsize/2 # round to nearest grid center	clim$longrid = floor(clim$lon/climgridsize)*climgridsize + climgridsize/2
write.csv(clim, file=paste('data/climGrid.csv', sep=''))
